<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CircuitLab ‚Äî Enhanced (Arrows scale, drag-wire, grid, export, undo/redo)</title>
<style>
:root{
  --bg:#071022; --panel:#0b1220; --accent:#10b981; --muted:#94a3b8; --fg:#dfefff;
}
html,body{margin:0;height:100%;font-family:Inter,Segoe UI,Arial;background:linear-gradient(180deg,#071022 0%, #071826 100%);color:var(--fg)}
.app{display:grid;grid-template-columns:300px 1fr 360px;grid-template-rows:56px 1fr;gap:12px;height:100vh;padding:12px;box-sizing:border-box}
header{grid-column:1/-1;background:rgba(255,255,255,0.02);border-radius:10px;padding:8px 14px;display:flex;align-items:center;gap:12px}
header h1{font-size:16px;margin:0}
.header-buttons{margin-left:auto;display:flex;gap:8px;align-items:center}
.panel{background:rgba(255,255,255,0.02);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.7)}
.left.panel{overflow:auto}
.palette .item{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;cursor:grab;display:flex;align-items:center;gap:8px;margin-bottom:6px}
.canvas-wrap{position:relative;border-radius:10px;overflow:hidden}
#canvas{width:100%;height:calc(100vh - 140px);display:block;cursor:crosshair;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent)}
.right.panel{display:flex;flex-direction:column;gap:10px}
.net-label{font-size:12px;font-weight:600;padding:2px 6px;border-radius:6px;background:rgba(16,185,129,0.12);color:var(--accent);border:1px solid rgba(16,185,129,0.12)}
.wire{stroke:#9fb6ff;stroke-width:4;stroke-linecap:round;stroke-linejoin:round;fill:none}
.wire-arrow{stroke:#10b981;stroke-linecap:round}
.voltage-text{font-size:12px;fill:#ffffff; font-weight:600; text-shadow: 0 1px 1px rgba(0,0,0,0.7);}
.component text{font-size:12px;fill:var(--fg)}
.component rect{fill:rgba(255,255,255,0.02);stroke:rgba(255,255,255,0.04);rx:6}
.log{background:rgba(255,255,255,0.01);padding:8px;border-radius:8px;max-height:160px;overflow:auto;font-size:13px}
.handle{fill:#10b981;cursor:pointer}
.grid-line{stroke:rgba(255,255,255,0.02);stroke-width:1}
.toolbar{display:flex;gap:8px;align-items:center}
.small{font-size:12px;color:var(--muted)}
.btn{padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
</style>
</head>
<body>
<div class="app">
  <header class="panel">
    <h1>CircuitLab ‚Äî Enhanced</h1>
    <div class="header-buttons toolbar">
      <button id="runSim" class="btn">Run DC Sim</button>
      <input id="selValue" placeholder="Value" />
      <button id="applyValue" class="btn">Apply</button>
      <button id="deleteSel" class="btn">Delete</button>
      <button id="undoBtn" class="btn">Undo (Ctrl+Z)</button>
      <button id="redoBtn" class="btn">Redo (Ctrl+Y)</button>
      <button id="exportJson" class="btn">Export JSON</button>
      <button id="exportSvg" class="btn">Export SVG</button>
      <label class="small" style="margin-left:8px">Grid:</label>
      <input id="gridToggle" type="checkbox" checked />
    </div>
  </header>

  <aside class="left panel">
    <div class="palette">
      <div class="item" draggable="true" data-type="wire">üîó Wire</div>
      <div class="item" draggable="true" data-type="resistor">Œ© Resistor</div>
      <div class="item" draggable="true" data-type="vsource">üîã V Source</div>
      <div class="item" draggable="true" data-type="ground">‚èö Ground</div>
      <hr/>
      <div><strong>Tools</strong></div>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="toolSelect" class="btn">Select</button>
        <button id="toolWire" class="btn">Draw Wire</button>
      </div>
      <small class="small" style="display:block;margin-top:8px">Draw Wire: click start ‚Üí click end. Holds orthogonal routing. Snaps to grid.</small>
    </div>
  </aside>

  <main class="canvas-wrap panel">
    <svg id="canvas" viewBox="0 0 1600 900" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%">
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#10b981" />
        </marker>
      </defs>
      <!-- grid and content appended by script -->
    </svg>
  </main>

  <aside class="right panel">
    <div><strong>Node Voltages</strong><div id="netList"></div></div>
    <div><strong>Currents</strong><div id="currentList"></div></div>
    <div><strong>Log</strong><div id="log" class="log"></div></div>
  </aside>
</div>

<script>
/* =========================
   State, undo/redo, tools
   ========================= */
let state = { components: [], wires: [], nextId: 1, selection: null };
let undoStack = [], redoStack = [];
function snapshotPush(){
  undoStack.push(JSON.stringify(state));
  if(undoStack.length>200) undoStack.shift();
  redoStack = []; // clear redo on new action
  updateUndoButtons();
}
function updateUndoButtons(){
  document.getElementById('undoBtn').disabled = undoStack.length===0;
  document.getElementById('redoBtn').disabled = redoStack.length===0;
}
function undo(){
  if(!undoStack.length) return;
  redoStack.push(JSON.stringify(state));
  const prev = undoStack.pop();
  state = JSON.parse(prev);
  render();
  updateUndoButtons();
  logMsg('Undo');
}
function redo(){
  if(!redoStack.length) return;
  undoStack.push(JSON.stringify(state));
  const next = redoStack.pop();
  state = JSON.parse(next);
  render();
  updateUndoButtons();
  logMsg('Redo');
}

// tools
let currentTool = 'select'; // 'select' | 'draw-wire'
document.getElementById('toolSelect').addEventListener('click', ()=> { currentTool='select'; logMsg('Tool: select'); });
document.getElementById('toolWire').addEventListener('click', ()=> { currentTool='draw-wire'; logMsg('Tool: draw wire'); });

/* =========================
   Helpers
   ========================= */
let draggingPoint = null, dragWire = null;
function uid(){ return (state.nextId++).toString(); }
const GRID = 16;
function snap(v){ return Math.round(v/GRID)*GRID; }
function svgPoint(x,y){
  const svg = document.getElementById('canvas');
  const pt = svg.createSVGPoint();
  pt.x=x; pt.y=y;
  return pt.matrixTransform(svg.getScreenCTM().inverse());
}
function logMsg(msg){ const d = document.createElement('div'); d.textContent = msg; document.getElementById('log').prepend(d); }

/* return every terminal (points on components/wires) */
function getAllTerminals(){
  const terminals=[];
  state.components.forEach(c=>c.points.forEach(p=>terminals.push({x:p.x,y:p.y})));
  state.wires.forEach(w=>w.points.forEach(p=>terminals.push({x:p.x,y:p.y})));
  return terminals;
}
function snapToTerminal(pt){
  const snapDist = 12;
  for(const t of getAllTerminals()){
    const dx=pt.x-t.x, dy=pt.y-t.y;
    if(Math.sqrt(dx*dx+dy*dy) < snapDist) return {x:t.x,y:t.y};
  }
  return pt;
}

/* orthogonal routing helper */
function createOrthogonalPoints(x1,y1,x2,y2){
  // L-shaped: horizontal then vertical or vertical then horizontal based on distance
  const dx = Math.abs(x2-x1), dy = Math.abs(y2-y1);
  if(dx >= dy) {
    return [{x:x1,y:y1},{x:x2,y:y1},{x:x2,y:y2}];
  } else {
    return [{x:x1,y:y1},{x:x1,y:y2},{x:x2,y:y2}];
  }
}

/* =========================
   Add components
   ========================= */
function addComponent(type, x, y){
  snapshotPush();
  const id = uid();
  const comp = { id, type, x, y, value: (type==='resistor'?1000:(type==='vsource'?5:0)), points: [{x:x-28,y},{x:x+28,y}] };
  if(type==='ground') comp.value = 0;
  if(type==='wire'){
    const pts = createOrthogonalPoints(x, y, x+80, y);
    state.wires.push({ id, points: pts });
  } else {
    state.components.push(comp);
  }
  render();
}

/* =========================
   Rendering (grid, wires, components, annotations)
   ========================= */
function render(){
  const svg = document.getElementById('canvas');
  while(svg.firstChild) svg.removeChild(svg.firstChild);

  // defs (arrow marker)
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  defs.innerHTML = `<marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
    <polygon points="0 0, 10 3.5, 0 7" fill="#10b981"/></marker>`;
  svg.appendChild(defs);

  // grid draw if enabled
  const gridOn = document.getElementById('gridToggle').checked;
  if(gridOn){
    const w = 1600, h = 900;
    for(let x=0;x<=w;x+=GRID){
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',x); line.setAttribute('y1',0); line.setAttribute('x2',x); line.setAttribute('y2',h);
      line.setAttribute('class','grid-line'); svg.appendChild(line);
    }
    for(let y=0;y<=h;y+=GRID){
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',0); line.setAttribute('y1',y); line.setAttribute('x2',w); line.setAttribute('y2',y);
      line.setAttribute('class','grid-line'); svg.appendChild(line);
    }
  }

  renderWires(svg);
  renderComponents(svg);
  computeAndShowNets(svg);
}

/* render wires (polyline) and small handles */
function renderWires(svg){
  state.wires.forEach(w=>{
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
    poly.setAttribute('points', w.points.map(p=>`${p.x},${p.y}`).join(' '));
    poly.setAttribute('class','wire');
    svg.appendChild(poly);

    // handles
    w.points.forEach((p,i)=>{
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx',p.x); c.setAttribute('cy',p.y); c.setAttribute('r',5); c.setAttribute('class','handle');
      c.addEventListener('mousedown', e => { draggingPoint = p; dragWire = w; e.stopPropagation(); });
      c.addEventListener('dblclick', e => { snapshotPush(); w.points.splice(i+1, 0, {x: p.x + GRID*1.5, y: p.y}); render(); });
      svg.appendChild(c);
    });
  });
}

/* render components with schematic symbols */
function renderComponents(svg){
  state.components.forEach(c=>{
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('class','component');
    g.setAttribute('transform', `translate(${c.x},${c.y})`);
    g.dataset.id = c.id;

    if(c.type === 'resistor'){
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const pts = [[-28,0],[-20,-10],[-12,10],[-4,-10],[4,10],[12,-10],[20,0]];
      poly.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      poly.setAttribute('stroke','#dfefff'); poly.setAttribute('fill','none'); poly.setAttribute('stroke-width','2');
      g.appendChild(poly);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x',0); t.setAttribute('y',-14); t.setAttribute('text-anchor','middle'); t.textContent = `${c.value}Œ©`; g.appendChild(t);
    } else if(c.type === 'vsource'){
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x',0); t.setAttribute('y',22); t.setAttribute('text-anchor','middle'); t.textContent = `${c.value}V`; g.appendChild(t);
      const lineL = document.createElementNS('http://www.w3.org/2000/svg','line');
      lineL.setAttribute('x1',-10); lineL.setAttribute('y1',-12); lineL.setAttribute('x2',-10); lineL.setAttribute('y2',12);
      lineL.setAttribute('stroke','#dfefff'); lineL.setAttribute('stroke-width','2'); g.appendChild(lineL);
      const lineS = document.createElementNS('http://www.w3.org/2000/svg','line');
      lineS.setAttribute('x1',10); lineS.setAttribute('y1',-6); lineS.setAttribute('x2',10); lineS.setAttribute('y2',6);
      lineS.setAttribute('stroke','#dfefff'); lineS.setAttribute('stroke-width','2'); g.appendChild(lineS);
    } else if(c.type === 'ground'){
      const l1 = document.createElementNS('http://www.w3.org/2000/svg','line'); l1.setAttribute('x1',0); l1.setAttribute('y1',0); l1.setAttribute('x2',0); l1.setAttribute('y2',8); l1.setAttribute('stroke','#dfefff'); g.appendChild(l1);
      const l2 = document.createElementNS('http://www.w3.org/2000/svg','line'); l2.setAttribute('x1',-8); l2.setAttribute('y1',8); l2.setAttribute('x2',8); l2.setAttribute('y2',8); l2.setAttribute('stroke','#dfefff'); g.appendChild(l2);
      const l3 = document.createElementNS('http://www.w3.org/2000/svg','line'); l3.setAttribute('x1',-5); l3.setAttribute('y1',10); l3.setAttribute('x2',5); l3.setAttribute('y2',10); l3.setAttribute('stroke','#dfefff'); g.appendChild(l3);
    }

    g.addEventListener('mousedown', e => { e.stopPropagation(); state.selection = { id: c.id, type: c.type }; document.getElementById('selValue').value = c.value; });
    g.addEventListener('dblclick', e => { e.stopPropagation(); const v = prompt('Value:', c.value); if(v !== null){ snapshotPush(); c.value = parseFloat(v) || 0; render(); } });

    svg.appendChild(g);
  });
}

/* =========================
   Mouse interactions (dragging handles & tool wire)
   ========================= */
document.addEventListener('mousemove', e => {
  if(draggingPoint){
    const ptRaw = svgPoint(e.clientX, e.clientY);
    const gridOn = document.getElementById('gridToggle').checked;
    const snapped = gridOn ? {x: snap(ptRaw.x), y: snap(ptRaw.y)} : snapToTerminal(ptRaw);
    draggingPoint.x = snapped.x; draggingPoint.y = snapped.y;
    render();
  } else if(currentTool === 'draw-wire' && wirePreview.active){
    // update preview end point
    const p = svgPoint(e.clientX, e.clientY);
    const gridOn = document.getElementById('gridToggle').checked;
    const pt = gridOn ? {x: snap(p.x), y: snap(p.y)} : snapToTerminal(p);
    wirePreview.end = pt;
    drawWirePreview();
  }
});
document.addEventListener('mouseup', ()=>{ draggingPoint = null; dragWire = null; });

/* =========================
   Drag-to-create-wire tool implementation
   ========================= */
let wirePreview = { active:false, start:null, end:null };
const svgCanvas = document.getElementById('canvas');
svgCanvas.addEventListener('mousedown', e => {
  // tool behavior
  const pt = svgPoint(e.clientX, e.clientY);
  const gridOn = document.getElementById('gridToggle').checked;
  const snapped = gridOn ? {x: snap(pt.x), y: snap(pt.y)} : snapToTerminal(pt);

  if(currentTool === 'draw-wire'){
    if(!wirePreview.active){
      // start
      wirePreview.active = true; wirePreview.start = snapped; wirePreview.end = snapped;
      drawWirePreview();
    } else {
      // finalize: create actual wire orthogonal between start and end
      snapshotPush();
      const pts = createOrthogonalPoints(wirePreview.start.x, wirePreview.start.y, snapped.x, snapped.y);
      state.wires.push({ id: uid(), points: pts });
      wirePreview.active = false; wirePreview.start = null; wirePreview.end = null;
      render();
    }
  }
});

function drawWirePreview(){
  render(); // clears canvas & redraws everything then we'll overlay preview
  if(!wirePreview.active) return;
  const svg = document.getElementById('canvas');
  const pts = createOrthogonalPoints(wirePreview.start.x, wirePreview.start.y, wirePreview.end.x, wirePreview.end.y);
  const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
  poly.setAttribute('points', pts.map(p=>`${p.x},${p.y}`).join(' '));
  poly.setAttribute('stroke','#7fb2ff'); poly.setAttribute('stroke-dasharray','6 4'); poly.setAttribute('stroke-width','3'); poly.setAttribute('fill','none');
  svg.appendChild(poly);
}

/* =========================
   DC Solver (MNA) + wire arrow scaling/coloring
   ========================= */
function computeAndShowNets(svg){
  // map physical terminals -> node ids
  const pointToNode = new Map();
  let nodeCounter = 1;
  function pointKey(p){ return `${p.x},${p.y}`; }
  function getNodeForPoint(p){
    const k = pointKey(p);
    if(pointToNode.has(k)) return pointToNode.get(k);
    const node = p.isGround ? 0 : nodeCounter++;
    pointToNode.set(k, node);
    return node;
  }

  // assign nodes to components and wires, merge wire endpoints
  state.components.forEach(c=>{
    c.nodes = c.points.map(p => {
      if(c.type === 'ground'){ p.isGround = true; return 0; }
      return getNodeForPoint(p);
    });
  });
  state.wires.forEach(w=>{
    w.nodes = w.points.map(getNodeForPoint);
    const n0 = w.nodes[0], n1 = w.nodes[w.nodes.length-1];
    if(n0 !== n1){
      // remap all keys with n1 -> n0
      for(const [k,v] of pointToNode.entries()) if(v === n1) pointToNode.set(k, n0);
    }
  });

  // unique nodes array and index mapping
  const uniqueNodes = [...new Set([...pointToNode.values()])];
  const nodeIndex = {}; uniqueNodes.forEach((n,i)=>nodeIndex[n]=i);
  const N = uniqueNodes.length;
  const vSources = state.components.filter(c=>c.type==='vsource');

  // MNA matrices
  const M = Array.from({length: N + vSources.length}, ()=>Array(N + vSources.length).fill(0));
  const rhs = Array(N + vSources.length).fill(0);
  function idxOf(node){ return nodeIndex.hasOwnProperty(node) ? nodeIndex[node] : 0; }

  // resistors
  state.components.filter(c=>c.type==='resistor').forEach(c=>{
    const n1 = idxOf(c.nodes[0]), n2 = idxOf(c.nodes[1]); const g = 1 / c.value;
    if(n1!==0) M[n1][n1]+=g;
    if(n2!==0) M[n2][n2]+=g;
    if(n1!==0 && n2!==0){ M[n1][n2]-=g; M[n2][n1]-=g; }
  });

  // voltage sources
  vSources.forEach((v,i)=>{
    const row = N + i;
    const n1 = idxOf(v.nodes[0]), n2 = idxOf(v.nodes[1]);
    if(n1!==0){ M[row][n1] = 1; M[n1][row] = 1; }
    if(n2!==0){ M[row][n2] = -1; M[n2][row] = -1; }
    rhs[row] = v.value;
  });

  // solve linear system (Gaussian elimination)
  function solve(A,b){
    const n = A.length;
    const B = A.map((r,i)=>[...r,b[i]]);
    for(let i=0;i<n;i++){
      let piv = i;
      for(let k=i+1;k<n;k++) if(Math.abs(B[k][i])>Math.abs(B[piv][i])) piv=k;
      [B[i],B[piv]]=[B[piv],B[i]];
      if(Math.abs(B[i][i])<1e-12) B[i][i]=1e-12;
      for(let k=i+1;k<n;k++){
        const f = B[k][i]/B[i][i];
        for(let j=i;j<=n;j++) B[k][j]-=f*B[i][j];
      }
    }
    const x = Array(n).fill(0);
    for(let i=n-1;i>=0;i--){
      let s = B[i][n];
      for(let j=i+1;j<n;j++) s -= B[i][j]*x[j];
      x[i] = s / B[i][i];
    }
    return x;
  }

  const sol = solve(M, rhs);
  const nodeVoltages = sol.slice(0,N);
  const vsrcCurrents = sol.slice(N);

  // show node voltages in right panel
  const netList = document.getElementById('netList'); netList.innerHTML = '';
  uniqueNodes.forEach((node,i)=>{
    const d = document.createElement('div'); d.className='net-label';
    d.textContent = `Node ${node}: ${(nodeVoltages[i]||0).toFixed(4)} V`;
    netList.appendChild(d);
  });

  // show component currents
  const currentList = document.getElementById('currentList'); currentList.innerHTML = '';
  state.components.forEach(c=>{
    if(c.type==='resistor'){
      const n1 = idxOf(c.nodes[0]), n2 = idxOf(c.nodes[1]);
      const v1 = nodeVoltages[n1]||0, v2 = nodeVoltages[n2]||0;
      const I = (v1 - v2) / c.value;
      const div = document.createElement('div'); div.textContent = `R${c.id} current: ${I.toExponential(6)} A`; currentList.appendChild(div);
    }
  });
  vSources.forEach((v,i)=>{ const div=document.createElement('div'); div.textContent=`V${v.id} current: ${ (vsrcCurrents[i]||0).toExponential(6) } A`; currentList.appendChild(div); });

  // compute representative positions for node labels
  const nodePos = {};
  for(const [k,v] of pointToNode.entries()){
    if(!nodePos.hasOwnProperty(v)){
      const [xs, ys] = k.split(',').map(Number);
      nodePos[v] = { x: xs + GRID/2, y: ys - GRID/2 };
    }
  }

  // draw node voltage texts on canvas
  Object.keys(nodePos).forEach(k=>{
    const node = Number(k), pos = nodePos[node];
    const vi = nodeIndex[node];
    const v = nodeVoltages[vi] || 0;
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', pos.x); t.setAttribute('y', pos.y); t.setAttribute('class','voltage-text');
    t.textContent = `${v.toFixed(2)} V`;
    svg.appendChild(t);
  });

  /* ---------- Wire arrows: thickness & color scale ---------- */
  // find max absolute current magnitude across segments to scale stroke width
  let maxMag = 0;
  const segCurrents = []; // list of {w, i, segIndex, I}
  state.wires.forEach(w=>{
    for(let i=0;i<w.points.length-1;i++){
      const p1 = w.points[i], p2 = w.points[i+1];
      const n1 = idxOf(w.nodes[i]), n2 = idxOf(w.nodes[i+1]);
      const v1 = nodeVoltages[n1]||0, v2 = nodeVoltages[n2]||0;
      const I = Math.abs(v1 - v2); // proportional to voltage difference; actual current through a wire depends on connected elements -- we use this proxy for visualization
      segCurrents.push({ w, segIndex:i, I, v1, v2 });
      if(I > maxMag) maxMag = I;
    }
  });
  if(maxMag === 0) maxMag = 1e-6;

  // helper: color map from green -> yellow -> red
  function colorForRatio(r){
    // r in [0,1]
    if(r<=0.5){
      // green -> yellow
      const t = r/0.5;
      const rC = Math.round(16 + (255-16)*t);
      const gC = Math.round(185 + (255-185)*t);
      const bC = Math.round(129 + (0-129)*t);
      return `rgb(${rC},${gC},${bC})`;
    } else {
      const t = (r-0.5)/0.5;
      const rC = Math.round(255 + (255-255)*t);
      const gC = Math.round(255 + (120-255)*t);
      const bC = Math.round(0 + (0-0)*t);
      return `rgb(${rC},${gC},${bC})`;
    }
  }

  // draw arrow for each segment
  segCurrents.forEach(s=>{
    const p1 = s.w.points[s.segIndex], p2 = s.w.points[s.segIndex+1];
    const mx = (p1.x + p2.x)/2, my = (p1.y + p2.y)/2;
    const lx = p2.x - p1.x, ly = p2.y - p1.y;
    // arrow endpoints between 35% and 65% along the segment
    const x1 = p1.x + lx*0.35, y1 = p1.y + ly*0.35;
    const x2 = p1.x + lx*0.65, y2 = p1.y + ly*0.65;
    const ratio = Math.min(1, s.I / maxMag);
    const strokeW = 1 + 6 * ratio; // 1..7 px
    const color = colorForRatio(ratio);
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
    line.setAttribute('stroke', color); line.setAttribute('stroke-width', strokeW);
    line.setAttribute('marker-end', 'url(#arrowhead)');
    svg.appendChild(line);

    // small numeric label
    const dv = (s.v1 - s.v2).toFixed(2);
    const vlabel = document.createElementNS('http://www.w3.org/2000/svg','text');
    vlabel.setAttribute('x', mx + 6); vlabel.setAttribute('y', my + 4); vlabel.setAttribute('font-size','11'); vlabel.setAttribute('fill', color);
    vlabel.textContent = `${dv}V`;
    svg.appendChild(vlabel);
  });

  // return for testing if needed
  return { nodeVoltages, vsrcCurrents };
}

/* =========================
   Buttons: apply/delete/run/export/undo/redo
   ========================= */
document.getElementById('applyValue').addEventListener('click', ()=>{
  if(!state.selection) return;
  const c = state.components.find(x=>x.id===state.selection.id);
  if(c){ snapshotPush(); c.value = parseFloat(document.getElementById('selValue').value) || c.value; render(); }
});
document.getElementById('deleteSel').addEventListener('click', ()=>{
  if(!state.selection) return;
  snapshotPush();
  state.components = state.components.filter(x=>x.id!==state.selection.id);
  state.wires = state.wires.filter(x=>x.id!==state.selection.id);
  state.selection = null;
  render();
});
document.getElementById('runSim').addEventListener('click', ()=>{ computeAndShowNets(document.getElementById('canvas')); logMsg('DC simulation complete'); });

document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

// export JSON (state)
document.getElementById('exportJson').addEventListener('click', ()=>{
  const data = JSON.stringify(state, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'circuit.json'; a.click(); URL.revokeObjectURL(url);
  logMsg('Exported JSON');
});

// export SVG
document.getElementById('exportSvg').addEventListener('click', ()=>{
  const svg = document.getElementById('canvas');
  const clone = svg.cloneNode(true);
  // inline styles: wrap in <svg> already has defs; we can serialize
  const s = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([s], {type:'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'circuit.svg'; a.click(); URL.revokeObjectURL(url);
  logMsg('Exported SVG');
});

/* keyboard shortcuts */
document.addEventListener('keydown', e=>{
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
});

/* palette drag/drop for components */
document.querySelectorAll('.palette .item').forEach(it=>it.addEventListener('dragstart', e=> e.dataTransfer.setData('text/plain', it.dataset.type)));
svgCanvas.addEventListener('dragover', e=> e.preventDefault());
svgCanvas.addEventListener('drop', e=>{
  e.preventDefault();
  const type = e.dataTransfer.getData('text/plain');
  const pt = svgPoint(e.clientX, e.clientY);
  const gridOn = document.getElementById('gridToggle').checked;
  const snapped = gridOn ? {x: snap(pt.x), y: snap(pt.y)} : snapToTerminal(pt);
  addComponent(type, snapped.x, snapped.y);
});

/* =========================
   Demo initial content and first snapshot
   ========================= */
addComponent('vsource', 220, 160);
addComponent('resistor', 420, 160);
addComponent('ground', 620, 160);
snapshotPush();
updateUndoButtons();

</script>
</body>
</html>
