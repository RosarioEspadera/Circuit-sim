<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CircuitLab ‚Äî Full (DC + Zoom/Pan)</title>
<style>
:root{
  --bg:#071122; --panel:#0b1220; --muted:#94a3b8; --accent:#10b981; --hot:#ff8a4b; --hot2:#ff4b4b;
}
*{box-sizing:border-box;user-select:none}
html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial,system-ui;background:linear-gradient(180deg,#071022,#071826);color:#e6eef8}
.app{display:grid;grid-template-columns:260px 1fr 320px;grid-template-rows:56px 1fr;gap:8px;height:100vh;padding:8px}
header{grid-column:1/-1;background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;display:flex;align-items:center;gap:8px}
header h1{font-size:15px;margin:0}
.toolbar{margin-left:auto;display:flex;gap:8px;align-items:center}
.btn{background:rgba(255,255,255,0.03);color:inherit;border:1px solid rgba(255,255,255,0.03);padding:6px 10px;border-radius:6px;cursor:pointer}
.panel{background:rgba(255,255,255,0.02);border-radius:8px;padding:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
.left.panel{overflow:auto}
.palette .item{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;cursor:grab;display:flex;align-items:center;gap:8px;margin-bottom:8px}
.canvas-wrap{position:relative;border-radius:8px;overflow:hidden}
#canvas{width:100%;height:calc(100vh - 140px);display:block;cursor:move;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent)}
.right.panel{display:flex;flex-direction:column;gap:10px}
.log{background:rgba(255,255,255,0.01);padding:8px;border-radius:8px;max-height:140px;overflow:auto;font-size:13px}
.net-label{font-size:12px;padding:2px 6px;border-radius:6px;background:rgba(16,185,129,0.12);color:var(--accent);display:inline-block;margin-bottom:6px}
.grid-line{stroke:rgba(255,255,255,0.04);stroke-width:1}
.wire{stroke:#7aa2ff;stroke-linecap:round;stroke-linejoin:round;fill:none;transition:stroke .12s linear, stroke-width .12s linear}
.handle{fill:var(--accent);cursor:pointer}
.component text{font-size:12px;fill:#dfefff;pointer-events:none}
.voltage-text{font-size:11px;fill:#fff;stroke:#000;stroke-width:.6px;pointer-events:none}
.wire-label{font-size:11px;fill:var(--accent);pointer-events:none}
.small{font-size:11px;color:var(--muted)}
kbd{background:#0b1220;border:1px solid rgba(255,255,255,0.03);padding:2px 6px;border-radius:4px}
</style>
</head>
<body>
<div class="app">
  <header class="panel">
    <h1>CircuitLab ‚Äî DC MNA Editor (zoom+pan)</h1>
    <div class="toolbar">
      <button id="newBtn" class="btn">New</button>
      <button id="undoBtn" class="btn">Undo</button>
      <button id="redoBtn" class="btn">Redo</button>
      <button id="exportJson" class="btn">Export JSON</button>
      <button id="exportSvg" class="btn">Export SVG</button>
      <label class="small" style="display:flex;align-items:center;gap:6px">Grid<input id="gridToggle" type="checkbox" checked/></label>
      <button id="runSim" class="btn">Run DC</button>
      <button id="runNgspiceBtn" class="btn" title="Optional: send netlist to external/wasm ngspice">Run with NgSpice (WASM)</button>
    </div>
  </header>

  <aside class="left panel">
    <div class="palette">
      <div class="item" draggable="true" data-type="wire">üîó Wire</div>
      <div class="item" draggable="true" data-type="resistor">Œ© Resistor</div>
      <div class="item" draggable="true" data-type="vsource">üîã V Source</div>
      <div class="item" draggable="true" data-type="ground">‚èö Ground</div>
    </div>
    <hr/>
    <div style="display:flex;gap:6px;margin-top:6px">
      <button id="toolSelect" class="btn">Select</button>
      <button id="toolWire" class="btn">Draw Wire</button>
    </div>
    <div style="margin-top:8px" class="small">
      Draw wire: click to place corners, double-click to finish.  
      Drag components / wire handles to move. Double-click to edit. Right-click to delete.  
      Zoom: mouse wheel (clamped 0.25√ó‚Äì4√ó). Pan: middle-button drag or Shift+drag.
    </div>
  </aside>

  <main class="canvas-wrap panel">
    <svg id="canvas" viewBox="0 0 1600 900" xmlns="http://www.w3.org/2000/svg">
      <!-- viewport group transformed for pan/zoom -->
      <g id="viewport"></g>
    </svg>
  </main>

  <aside class="right panel">
    <div>
      <strong>Inspector</strong>
      <div style="margin-top:8px">
        <div style="display:flex;gap:6px;align-items:center">
          <div style="width:80px;color:var(--muted)">Selected</div>
          <div id="selInfo">‚Äî</div>
        </div>
        <div style="margin-top:6px;display:flex;gap:6px">
          <input id="selValue" placeholder="value or label" />
          <button id="applyValue" class="btn">Apply</button>
        </div>
        <div style="margin-top:6px">
          <button id="deleteSel" class="btn" style="background:#9b2b2b">Delete</button>
        </div>
      </div>
    </div>

    <div class="panel">
      <strong>Node Voltages</strong>
      <div id="netList" style="margin-top:8px"></div>
    </div>

    <div class="panel">
      <strong>Log</strong>
      <div id="log" class="log"></div>
    </div>
  </aside>
</div>

<script>
/* =========================
   State & Undo/Redo
   ========================= */
const GRID = 16;
let state = { components: [], wires: [], nextId: 1, selection: null };
let undoStack = [], redoStack = [];
function uid(){ return (state.nextId++).toString(); }
function snapshot(){ undoStack.push(JSON.stringify(state)); if(undoStack.length>500) undoStack.shift(); redoStack=[]; updateUndoButtons(); }
function updateUndoButtons(){ document.getElementById('undoBtn').disabled = undoStack.length===0; document.getElementById('redoBtn').disabled = redoStack.length===0; }
function undo(){ if(!undoStack.length) return; redoStack.push(JSON.stringify(state)); state = JSON.parse(undoStack.pop()); render(); updateUndoButtons(); log('Undo'); }
function redo(){ if(!redoStack.length) return; undoStack.push(JSON.stringify(state)); state = JSON.parse(redoStack.pop()); render(); updateUndoButtons(); log('Redo'); }
function log(msg){ const e=document.getElementById('log'); const d=document.createElement('div'); d.textContent = `${new Date().toLocaleTimeString()}  ‚Äî  ${msg}`; e.prepend(d); }

/* =========================
   Viewport transform (pan/zoom)
   ========================= */
const svg = document.getElementById('canvas');
const viewport = document.getElementById('viewport');
let scale = 1.0;
let tx = 0, ty = 0;
const MIN_SCALE = 0.25, MAX_SCALE = 4.0;

function applyTransform(){
  viewport.setAttribute('transform', `translate(${tx},${ty}) scale(${scale})`);
}
applyTransform();

function screenToWorld(clientX, clientY){
  const rect = svg.getBoundingClientRect();
  const sx = clientX - rect.left;
  const sy = clientY - rect.top;
  return { x: (sx - tx) / scale, y: (sy - ty) / scale };
}
function worldToScreenClient(wx, wy){
  const rect = svg.getBoundingClientRect();
  const sx = wx * scale + tx + rect.left;
  const sy = wy * scale + ty + rect.top;
  return { x: sx, y: sy };
}
function worldToScreen(wx, wy){
  return { x: wx * scale + tx, y: wy * scale + ty };
}

/* === Wheel zoom centered on cursor === */
svg.addEventListener('wheel', e=>{
  if(e.ctrlKey) return;
  e.preventDefault();
  const rect = svg.getBoundingClientRect();
  const localX = e.clientX - rect.left;
  const localY = e.clientY - rect.top;
  const worldBefore = screenToWorld(e.clientX, e.clientY);
  const factor = Math.exp(-e.deltaY * 0.0012);
  let newScale = scale * factor;
  newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
  tx = localX - worldBefore.x * newScale;
  ty = localY - worldBefore.y * newScale;
  scale = newScale;
  applyTransform();
  render();
}, {passive:false});

/* === Panning: middle-button drag or Shift+left-drag === */
let panning = false, panStart = null;
svg.addEventListener('mousedown', e=>{
  if(e.button === 1 || (e.button === 0 && e.shiftKey)){
    panning = true;
    panStart = { x: e.clientX, y: e.clientY, tx, ty };
    document.addEventListener('mousemove', panMove);
    document.addEventListener('mouseup', panEnd);
    e.preventDefault();
  }
});
function panMove(e){
  if(!panning) return;
  tx = panStart.tx + (e.clientX - panStart.x);
  ty = panStart.ty + (e.clientY - panStart.y);
  applyTransform();
}
function panEnd(e){
  panning = false; panStart = null;
  document.removeEventListener('mousemove', panMove);
  document.removeEventListener('mouseup', panEnd);
}

/* =========================
   Geometry helpers
   ========================= */
function snapCoord(x){ return Math.round(x/GRID) * GRID; }
function getAllTerminals(){
  const t=[];
  state.components.forEach(c=>c.points.forEach(p=>t.push({x:Math.round(p.x),y:Math.round(p.y)})));
  state.wires.forEach(w=>w.points.forEach(p=>t.push({x:Math.round(p.x),y:Math.round(p.y)})));
  return t;
}
function snapToTerminal(pt){
  const D = 12;
  for(const t of getAllTerminals()){
    const dx = pt.x - t.x, dy = pt.y - t.y;
    if(Math.hypot(dx,dy) < D) return {x:t.x,y:t.y};
  }
  return pt;
}
function orthogonalRoute(p1, p2){
  const dx = Math.abs(p2.x - p1.x), dy = Math.abs(p2.y - p1.y);
  if(dx === 0 || dy === 0) return [p1, p2];
  return [p1, {x:p2.x, y:p1.y}, p2];
}

/* =========================
   Add components / wires
   ========================= */
function addComponent(type, x, y){
  snapshot();
  if(type === 'wire'){
    const pts = orthogonalRoute({x,y}, {x:x+GRID*4, y});
    state.wires.push({ id: uid(), points: pts, label: '' });
  } else {
    const comp = { id: uid(), type, x, y, value: (type==='resistor'?1000:(type==='vsource'?5:0)), points:[{x:x-28,y},{x:x+28,y}] };
    if(type==='ground') comp.value = 0;
    state.components.push(comp);
  }
  render();
}

/* =========================
   Rendering (compensated for zoom)
   ========================= */
function clearViewport(){ while(viewport.firstChild) viewport.removeChild(viewport.firstChild); }

function render(){
  clearViewport();
  const invScale = 1 / scale;

  // grid
  if(document.getElementById('gridToggle').checked){
    const viewW = 1600, viewH = 900;
    for(let x=0;x<=viewW;x+=GRID){
      const l = document.createElementNS('http://www.w3.org/2000/svg','line');
      l.setAttribute('x1', x); l.setAttribute('y1', 0); l.setAttribute('x2', x); l.setAttribute('y2', viewH);
      l.setAttribute('class','grid-line'); viewport.appendChild(l);
    }
    for(let y=0;y<=viewH;y+=GRID){
      const l = document.createElementNS('http://www.w3.org/2000/svg','line');
      l.setAttribute('x1', 0); l.setAttribute('y1', y); l.setAttribute('x2', viewW); l.setAttribute('y2', y);
      l.setAttribute('class','grid-line'); viewport.appendChild(l);
    }
  }

  // wires
  state.wires.forEach(w=>{
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
    poly.setAttribute('points', w.points.map(p=>`${p.x},${p.y}`).join(' '));
    poly.setAttribute('class','wire');
    poly.dataset.id = w.id;
    poly.setAttribute('stroke-width', (4 * invScale).toString());
    poly.addEventListener('dblclick', e=>{ e.stopPropagation(); editWireLabel(w); });
    poly.addEventListener('contextmenu', e=>{ e.preventDefault(); e.stopPropagation(); deleteWire(w.id); });
    poly.addEventListener('mousedown', e=> e.stopPropagation());
    viewport.appendChild(poly);

    if(w.label){
      const mid = w.points[Math.floor(w.points.length/2)];
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', mid.x + 6); t.setAttribute('y', mid.y - 6);
      t.setAttribute('class','wire-label');
      t.setAttribute('font-size', (11 * invScale).toString());
      t.textContent = w.label;
      viewport.appendChild(t);
    }

    // handles
    w.points.forEach((pt, idx)=>{
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', pt.x); c.setAttribute('cy', pt.y);
      c.setAttribute('r', (5 * invScale).toString());
      c.setAttribute('class','handle');
      c.dataset.wid = w.id; c.dataset.idx = idx;
      c.addEventListener('mousedown', e=>{ e.stopPropagation(); startDragPoint(w, idx, e); });
      c.addEventListener('dblclick', e=>{ e.stopPropagation(); snapshot(); w.points.splice(idx+1,0,{x:pt.x+GRID*1.5,y:pt.y}); render(); });
      c.addEventListener('contextmenu', e=>{ e.preventDefault(); e.stopPropagation(); deleteWire(w.id); });
      viewport.appendChild(c);
    });
  });

  // components
  state.components.forEach(c=>{
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${c.x},${c.y})`);
    g.dataset.id = c.id;

    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', -36); rect.setAttribute('y', -18); rect.setAttribute('width', 72); rect.setAttribute('height', 36); rect.setAttribute('rx',6);
    rect.setAttribute('fill','rgba(255,255,255,0.02)');
    rect.setAttribute('stroke','rgba(255,255,255,0.04)');
    rect.setAttribute('stroke-width', (1 * invScale).toString());
    rect.style.cursor = 'move';
    rect.addEventListener('mousedown', e=>{ e.stopPropagation(); startDragComp(c, e); });
    rect.addEventListener('dblclick', e=>{ e.stopPropagation(); editCompValue(c); });
    rect.addEventListener('contextmenu', e=>{ e.preventDefault(); e.stopPropagation(); deleteComp(c.id); });
    g.appendChild(rect);

    if(c.type === 'resistor'){
      const pts=[[-28,0],[-20,-10],[-12,10],[-4,-10],[4,10],[12,-10],[20,0]];
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      poly.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      poly.setAttribute('stroke','#dfefff'); poly.setAttribute('fill','none');
      poly.setAttribute('stroke-width', (2 * invScale).toString());
      g.appendChild(poly);

      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
      txt.setAttribute('x',0); txt.setAttribute('y',-14); txt.setAttribute('text-anchor','middle');
      txt.setAttribute('font-size', (12 * invScale).toString());
      txt.textContent = `${c.value}Œ©`;
      g.appendChild(txt);
    } else if(c.type==='vsource'){
      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
      txt.setAttribute('x',0); txt.setAttribute('y',22); txt.setAttribute('text-anchor','middle');
      txt.setAttribute('font-size', (12 * invScale).toString());
      txt.textContent = `${c.value}V`;
      g.appendChild(txt);

      const l1 = document.createElementNS('http://www.w3.org/2000/svg','line');
      l1.setAttribute('x1',-10); l1.setAttribute('y1',-12); l1.setAttribute('x2',-10); l1.setAttribute('y2',12);
      l1.setAttribute('stroke','#dfefff'); l1.setAttribute('stroke-width', (2 * invScale).toString()); g.appendChild(l1);

      const l2 = document.createElementNS('http://www.w3.org/2000/svg','line');
      l2.setAttribute('x1',10); l2.setAttribute('y1',-6); l2.setAttribute('x2',10); l2.setAttribute('y2',6);
      l2.setAttribute('stroke','#dfefff'); l2.setAttribute('stroke-width', (2 * invScale).toString()); g.appendChild(l2);
    } else if(c.type==='ground'){
      const l1 = document.createElementNS('http://www.w3.org/2000/svg','line'); l1.setAttribute('x1',0); l1.setAttribute('y1',0); l1.setAttribute('x2',0); l1.setAttribute('y2',8); l1.setAttribute('stroke','#dfefff'); l1.setAttribute('stroke-width', (1 * invScale).toString()); g.appendChild(l1);
      const l2 = document.createElementNS('http://www.w3.org/2000/svg','line'); l2.setAttribute('x1',-8); l2.setAttribute('y1',8); l2.setAttribute('x2',8); l2.setAttribute('y2',8); l2.setAttribute('stroke','#dfefff'); l2.setAttribute('stroke-width', (1 * invScale).toString()); g.appendChild(l2);
      const l3 = document.createElementNS('http://www.w3.org/2000/svg','line'); l3.setAttribute('x1',-5); l3.setAttribute('y1',10); l3.setAttribute('x2',5); l3.setAttribute('y2',10); l3.setAttribute('stroke','#dfefff'); l3.setAttribute('stroke-width', (1 * invScale).toString()); g.appendChild(l3);
    }

    viewport.appendChild(g);

    // terminals dots
    c.points = [{x: c.x - 28, y: c.y}, {x: c.x + 28, y: c.y}];
    c.points.forEach(pt=>{
      const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
      dot.setAttribute('cx', pt.x); dot.setAttribute('cy', pt.y);
      dot.setAttribute('r', (3 * invScale).toString());
      dot.setAttribute('fill','#a8d8c2');
      viewport.appendChild(dot);
    });
  });

  // compute & style
  const sim = computeAndShowNets();
  styleWiresByCurrent(sim, 1/scale);
  drawNodeLabels(sim, 1/scale);
}

/* =========================
   Dragging components & wire points
   ========================= */
function startDragComp(comp, e){
  function move(ev){
    ev.preventDefault();
    const world = screenToWorld(ev.clientX, ev.clientY);
    const gridOn = document.getElementById('gridToggle').checked;
    comp.x = gridOn ? snapCoord(world.x) : world.x;
    comp.y = gridOn ? snapCoord(world.y) : world.y;
    render();
  }
  function up(ev){
    document.removeEventListener('mousemove', move);
    document.removeEventListener('mouseup', up);
    snapshot(); log('Moved component');
  }
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', up);
}

function startDragPoint(wire, idx, e){
  function move(ev){
    ev.preventDefault();
    const world = screenToWorld(ev.clientX, ev.clientY);
    const gridOn = document.getElementById('gridToggle').checked;
    const snapped = gridOn ? {x: snapCoord(world.x), y: snapCoord(world.y)} : snapToTerminal(world);
    wire.points[idx] = snapped;
    render();
  }
  function up(ev){
    document.removeEventListener('mousemove', move);
    document.removeEventListener('mouseup', up);
    snapshot(); log('Moved wire handle');
  }
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', up);
}

/* =========================
   Edit / Delete
   ========================= */
function editCompValue(comp){
  const v = prompt('Value (Œ© for resistor, V for vsource):', comp.value);
  if(v !== null){ snapshot(); comp.value = parseFloat(v) || comp.value; render(); log('Edited component value'); }
}
function editWireLabel(wire){
  const v = prompt('Wire label / net name (optional):', wire.label || '');
  if(v !== null){ snapshot(); wire.label = v; render(); log('Edited wire label'); }
}
function deleteComp(id){ snapshot(); state.components = state.components.filter(c=>c.id !== id); if(state.selection && state.selection.id==id) state.selection = null; render(); log('Deleted component'); }
function deleteWire(id){ snapshot(); state.wires = state.wires.filter(w=>w.id !== id); if(state.selection && state.selection.id==id) state.selection = null; render(); log('Deleted wire'); }

/* =========================
   Click selection & inspector
   ========================= */
svg.addEventListener('mousedown', e=>{
  if(e.button === 1) return;

  const world = screenToWorld(e.clientX, e.clientY);

  // wire hit using world-threshold equivalent of 6 screen px
  const wireHitThresholdWorld = 6 / scale;
  let hitWire = null;
  state.wires.forEach(w=>{
    for(let i=0;i<w.points.length-1;i++){
      const a = w.points[i], b = w.points[i+1];
      const d = pointSegmentDistance(world, a, b);
      if(d < wireHitThresholdWorld){ hitWire = w; break; }
    }
  });
  if(hitWire){
    state.selection = {id: hitWire.id, type: 'wire'};
    document.getElementById('selInfo').textContent = `wire ${hitWire.id}`;
    document.getElementById('selValue').value = hitWire.label || '';
    return;
  }

  // component hit test in screen space
  let hitComp = null;
  for(const c of state.components){
    const sc = worldToScreenClient(c.x, c.y);
    const halfWpx = 36 * scale;
    const halfHpx = 18 * scale;
    if(Math.abs(e.clientX - sc.x) <= halfWpx && Math.abs(e.clientY - sc.y) <= halfHpx){ hitComp = c; break; }
  }
  if(hitComp){
    state.selection = {id: hitComp.id, type: 'component'};
    document.getElementById('selInfo').textContent = `${hitComp.type} ${hitComp.id}`;
    document.getElementById('selValue').value = hitComp.value || '';
  } else {
    state.selection = null;
    document.getElementById('selInfo').textContent = '‚Äî';
    document.getElementById('selValue').value = '';
  }
});

function pointSegmentDistance(p, a, b){
  const vx = b.x - a.x, vy = b.y - a.y;
  const wx = p.x - a.x, wy = p.y - a.y;
  const c1 = vx*wx + vy*wy;
  if(c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
  const c2 = vx*vx + vy*vy;
  if(c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
  const t = c1 / c2;
  const projx = a.x + t*vx, projy = a.y + t*vy;
  return Math.hypot(p.x - projx, p.y - projy);
}

/* inspector actions */
document.getElementById('applyValue').addEventListener('click', ()=>{
  const sel = state.selection;
  if(!sel) return;
  if(sel.type === 'component'){
    const c = state.components.find(x=>x.id==sel.id);
    if(c){ snapshot(); c.value = parseFloat(document.getElementById('selValue').value) || c.value; render(); log('Applied component value'); }
  } else if(sel.type === 'wire'){
    const w = state.wires.find(x=>x.id==sel.id);
    if(w){ snapshot(); w.label = document.getElementById('selValue').value; render(); log('Applied wire label'); }
  }
});
document.getElementById('deleteSel').addEventListener('click', ()=>{
  const sel = state.selection;
  if(!sel) return;
  if(sel.type === 'component') deleteComp(sel.id);
  else if(sel.type === 'wire') deleteWire(sel.id);
  document.getElementById('selInfo').textContent = '‚Äî';
  document.getElementById('selValue').value = '';
});

svg.addEventListener('contextmenu', e=> e.preventDefault());

window.addEventListener('keydown', e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
  if(e.key === 'Delete' && state.selection){ if(state.selection.type === 'component') deleteComp(state.selection.id); else deleteWire(state.selection.id); render(); }
});

/* =========================
   Wire drawing preview
   ========================= */
let currentTool = 'select';
document.getElementById('toolSelect').addEventListener('click', ()=> { currentTool = 'select'; log('Tool: select'); });
document.getElementById('toolWire').addEventListener('click', ()=> { currentTool = 'draw-wire'; log('Tool: draw-wire'); });

let preview = { active: false, points: [] };

svg.addEventListener('click', e=>{
  if(currentTool !== 'draw-wire') return;
  const world = screenToWorld(e.clientX, e.clientY);
  const gridOn = document.getElementById('gridToggle').checked;
  const pt = gridOn ? {x: snapCoord(world.x), y: snapCoord(world.y)} : snapToTerminal(world);
  if(!preview.active){
    preview.active = true; preview.points = [pt]; render(); drawPreview(); return;
  }
  const last = preview.points[preview.points.length - 1];
  if(last.x === pt.x || last.y === pt.y){
    preview.points.push(pt);
  } else {
    preview.points.push({x: pt.x, y: last.y});
    preview.points.push(pt);
  }
  render(); drawPreview();
});

svg.addEventListener('dblclick', e=>{
  if(currentTool === 'draw-wire' && preview.active){
    if(preview.points.length >= 2){
      snapshot();
      state.wires.push({ id: uid(), points: preview.points.map(p=>({x:p.x,y:p.y})), label:'' });
      preview.active = false; preview.points = [];
      render(); log('Added wire');
    } else {
      preview.active = false; preview.points = [];
      render();
    }
  }
});

function drawPreview(){
  if(!preview.active) return;
  const invScale = 1 / scale;
  const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
  poly.setAttribute('points', preview.points.map(p=>`${p.x},${p.y}`).join(' '));
  poly.setAttribute('class','wire');
  poly.setAttribute('stroke','#7fb2ff');
  poly.setAttribute('stroke-width', (3 * invScale).toString());
  poly.setAttribute('stroke-dasharray','6 4');
  viewport.appendChild(poly);
  preview.points.forEach(pt=>{
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx', pt.x); c.setAttribute('cy', pt.y);
    c.setAttribute('r', (3 * invScale).toString());
    c.setAttribute('fill','#6ee7b7');
    viewport.appendChild(c);
  });
}

/* =========================
   MNA DC Solver (robust)
   - Builds netlist-like map, forms MNA, solves
   ========================= */
function computeAndShowNets(){
  // Build mapping from coordinate keys -> node id
  const coordToRaw = new Map();
  let rawCounter = 0;
  const key = (p) => `${Math.round(p.x)},${Math.round(p.y)}`;

  function addCoord(pt){
    const k = key(pt);
    if(!coordToRaw.has(k)) coordToRaw.set(k, ++rawCounter);
    return coordToRaw.get(k);
  }

  // register pins and wires
  state.components.forEach(c=>{
    c.points = [{x: c.x - 28, y: c.y}, {x: c.x + 28, y: c.y}];
    c.points.forEach(p => addCoord(p));
  });
  state.wires.forEach(w => w.points.forEach(p => addCoord(p)));

  // If no nodes, nothing to compute
  if(coordToRaw.size === 0){ updateNodeList([], []); return { nodeV: [], uniqRaw: [], coordToRaw }; }

  // Find ground node raw id
  let groundRaw = null;
  for(const c of state.components){
    if(c.type === 'ground'){
      const r = coordToRaw.get(key(c.points[0]));
      if(r) { groundRaw = r; break; }
    }
  }
  if(groundRaw === null) {
    // pick an arbitrary node as ground so MNA is solvable
    groundRaw = Array.from(coordToRaw.values())[0];
  }

  // Build uniq list and map to indices
  const uniqRaw = Array.from(new Set(coordToRaw.values()));
  const rawToIndex = {}; uniqRaw.forEach((r,i) => rawToIndex[r] = i);
  const N = uniqRaw.length;

  // Components categorized
  const Rlist = state.components.filter(c => c.type === 'resistor');
  const Vsrcs = state.components.filter(c => c.type === 'vsource');

  // MNA size: (N-1) node unknowns (exclude ground) + number of voltage sources
  const nodeUnknowns = N - 1;
  const M = nodeUnknowns + Vsrcs.length;
  if(M <= 0){
    // only single node, all zero
    const nodeV = uniqRaw.map(r => (r===groundRaw? 0 : 0));
    updateNodeList(nodeV, uniqRaw);
    return { nodeV, uniqRaw, coordToRaw, rawToIndex, compCurrents: new Map() };
  }

  // helpers to convert raw -> compact index in unknown vector
  function compactIdx(raw){
    if(raw === groundRaw) return -1;
    const idx = rawToIndex[raw];
    const groundIndex = rawToIndex[groundRaw];
    return idx < groundIndex ? idx : idx - 1;
  }

  // Initialize M and RHS
  const A = Array.from({length:M}, ()=> Array(M).fill(0));
  const b = Array(M).fill(0);

  // stamp resistors into nodal submatrix
  Rlist.forEach(r => {
    const aRaw = coordToRaw.get(key(r.points[0]));
    const bRaw = coordToRaw.get(key(r.points[1]));
    const a = compactIdx(aRaw), bb = compactIdx(bRaw);
    const G = 1 / Math.max(1e-12, Number(r.value));
    if(a !== -1) A[a][a] += G;
    if(bb !== -1) A[bb][bb] += G;
    if(a !== -1 && bb !== -1){ A[a][bb] -= G; A[bb][a] -= G; }
  });

  // stamp voltage sources: rows and cols for extra unknowns
  Vsrcs.forEach((v, vi) => {
    const aRaw = coordToRaw.get(key(v.points[0]));
    const bRaw = coordToRaw.get(key(v.points[1]));
    const a = compactIdx(aRaw), bb = compactIdx(bRaw);
    const row = nodeUnknowns + vi;
    if(a !== -1){ A[row][a] = 1; A[a][row] = 1; }
    if(bb !== -1){ A[row][bb] = -1; A[bb][row] = -1; }
    b[row] = Number(v.value) || 0;
  });

  // Solve with Gaussian elimination (safe for small systems)
  function solveLinear(mat, rhs){
    const n = mat.length;
    // augmented
    const B = mat.map((r,i) => [...r, rhs[i]]);
    for(let i=0;i<n;i++){
      // pivot
      let p = i;
      for(let k=i+1;k<n;k++) if(Math.abs(B[k][i]) > Math.abs(B[p][i])) p = k;
      if(Math.abs(B[p][i]) < 1e-15) continue;
      [B[i], B[p]] = [B[p], B[i]];
      const pivot = B[i][i];
      for(let k=i+1;k<n;k++){
        const f = B[k][i] / pivot;
        for(let j=i;j<=n;j++) B[k][j] -= f * B[i][j];
      }
    }
    const x = Array(n).fill(0);
    for(let i=n-1;i>=0;i--){
      let s = B[i][n];
      for(let j=i+1;j<n;j++) s -= B[i][j] * x[j];
      x[i] = Math.abs(B[i][i]) < 1e-15 ? 0 : s / B[i][i];
    }
    return x;
  }

  let sol = [];
  if(M>0) sol = solveLinear(A, b);

  // reconstruct node voltages for every uniqRaw (including ground)
  const nodeV = uniqRaw.map((raw) => {
    if(raw === groundRaw) return 0;
    const cidx = compactIdx(raw);
    return (cidx >=0 && cidx < sol.length) ? sol[cidx] : 0;
  });

  // compute currents (positive from pin0 -> pin1)
  const compCurrents = new Map();
  Rlist.forEach(r=>{
    const aRaw = coordToRaw.get(key(r.points[0])), bRaw = coordToRaw.get(key(r.points[1]));
    const vA = nodeV[ rawToIndex[aRaw] ] || 0;
    const vB = nodeV[ rawToIndex[bRaw] ] || 0;
    const i = (vA - vB) / Math.max(1e-12, Number(r.value));
    compCurrents.set(r.id, i);
  });
  Vsrcs.forEach((v, vi)=> {
    // current through voltage source is in the extra unknowns part
    const iVal = sol[nodeUnknowns + vi] || 0;
    compCurrents.set(v.id, iVal);
  });

  // nodeCurrentSum used for styling
  const nodeCurrentSum = new Map();
  state.components.forEach(c=>{
    const cur = Math.abs(compCurrents.get(c.id) || 0);
    c.points.forEach(p=>{
      const r = coordToRaw.get(key(p));
      const idx = rawToIndex[r];
      nodeCurrentSum.set(idx, (nodeCurrentSum.get(idx)||0) + cur);
    });
  });

  updateNodeList(nodeV, uniqRaw);
  return { nodeV, uniqRaw, coordToRaw, rawToIndex, nodeCurrentSum, compCurrents, groundRaw };
}

function updateNodeList(nodeV, uniqRaw){
  const netList = document.getElementById('netList'); netList.innerHTML = '';
  if(!nodeV || nodeV.length === 0){ netList.textContent = '(no nodes)'; return; }
  uniqRaw.forEach((raw, i)=>{
    const d = document.createElement('div'); d.className = 'net-label';
    d.textContent = `Node ${raw}: ${ (nodeV[i]||0).toFixed(3) } V`;
    netList.appendChild(d);
  });
}

/* =========================
   Styling wires by current
   ========================= */
function styleWiresByCurrent(sim, invScale = 1){
  if(!sim) return;
  const { nodeCurrentSum, rawToIndex, coordToRaw } = sim;
  if(!nodeCurrentSum || !rawToIndex || !coordToRaw) return;
  let maxI = 0;
  nodeCurrentSum.forEach(v=>{ if(Math.abs(v) > maxI) maxI = Math.abs(v); });
  if(maxI < 1e-12) maxI = 1e-12;
  state.wires.forEach(w=>{
    const poly = viewport.querySelector(`polyline[data-id="${w.id}"]`);
    if(!poly) return;
    let sum = 0;
    w.points.forEach(p=>{
      const raw = coordToRaw.get(`${Math.round(p.x)},${Math.round(p.y)}`);
      if(raw !== undefined){
        const idx = rawToIndex[raw];
        if(idx !== undefined) sum += Math.abs(nodeCurrentSum.get(idx) || 0);
      }
    });
    const avg = sum / Math.max(1, w.points.length);
    const t = Math.min(1, avg / maxI);
    const minW = 2, maxW = 10;
    const widthPx = minW + t * (maxW - minW);
    poly.setAttribute('stroke-width', (widthPx * invScale).toString());
    const r = Math.round(127 + t * 128);
    const g = Math.round(180 - t * 180);
    const b = Math.round(255 - t * 255);
    poly.setAttribute('stroke', `rgb(${r},${g},${b})`);
  });
}

/* =========================
   Draw node voltage labels
   ========================= */
function drawNodeLabels(sim, invScale = 1){
  if(!sim) return;
  const { nodeV, uniqRaw, coordToRaw, rawToIndex, groundRaw } = sim;
  if(!nodeV) return;
  uniqRaw.forEach((raw, i)=>{
    if(raw === groundRaw) return;
    const coord = Array.from(coordToRaw.entries()).find(([k,v]) => v === raw);
    if(!coord) return;
    const [key,] = coord;
    const [x,y] = key.split(',').map(Number);
    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x', x+6);
    txt.setAttribute('y', y-6);
    txt.setAttribute('class','voltage-text');
    txt.setAttribute('font-size', (11 * invScale).toString());
    txt.textContent = `${nodeV[i].toFixed(2)}V`;
    viewport.appendChild(txt);
  });
}

/* =========================
   Export / demo / util
   ========================= */
document.getElementById('exportJson').addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='circuit.json'; a.click(); URL.revokeObjectURL(a.href);
  log('Exported JSON');
});
document.getElementById('exportSvg').addEventListener('click', ()=>{
  const cloneSvg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  cloneSvg.setAttribute('viewBox', '0 0 1600 900');
  cloneSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  const clone = viewport.cloneNode(true);
  clone.querySelectorAll('.handle').forEach(h=>h.remove());
  cloneSvg.appendChild(clone);
  const s = new XMLSerializer().serializeToString(cloneSvg);
  const blob = new Blob([s], {type:'image/svg+xml'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='circuit.svg'; a.click(); URL.revokeObjectURL(a.href);
  log('Exported SVG');
});

/* =========================
   Buttons & shortcuts
   ========================= */
document.getElementById('runSim').addEventListener('click', ()=>{ render(); log('DC solve complete'); });
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);
document.getElementById('newBtn').addEventListener('click', ()=>{ snapshot(); state = {components:[], wires:[], nextId:1, selection:null}; render(); log('New'); });

window.addEventListener('keydown', e=>{
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
  if(e.key === 'Delete' && state.selection){
    if(state.selection.type === 'component') deleteComp(state.selection.id);
    else deleteWire(state.selection.id);
    render();
  }
});

/* Demo content */
function addSample(){
  snapshot();
  addComponent('vsource', 200, 160);
  addComponent('resistor', 420, 160);
  addComponent('ground', 640, 160);
  state.wires.push({ id: uid(), points: orthogonalRoute({x:228,y:160},{x:372,y:160}), label:'' });
  state.wires.push({ id: uid(), points: orthogonalRoute({x:448,y:160},{x:640,y:160}), label:'' });
  render();
  updateUndoButtons();
}
addSample();

/* =========================
   NgSpice (WASM) hook
   - loadNgSpice(wasmUrl) should initialize the wasm engine
   - runNgSpice(netlist) should call the wasm engine and return results
   - Below are simple placeholders; to integrate, adapt to the specific ngspice-js API you use.
   ========================= */

let ngspiceReady = false;
let ngspiceModule = null;
// Example loader - adapt to the ngspice wasm build you have
async function loadNgSpice(wasmUrl){
  // Example: if using a library that exposes createNgspiceModule(...)
  // ngspiceModule = await createNgspiceModule({ wasmBinaryFile: wasmUrl });
  // ngspiceReady = true;
  // log('NgSpice WASM loaded');
  log('loadNgSpice called ‚Äî please adapt loadNgSpice() to your ngspice-wasm build and call it with the wasm URL.');
}

// Example wrapper: convert current editor circuit to a SPICE netlist string
function buildSpiceNetlist(){
  // Simple netlist: node names are integers from MNA mapping
  const sim = computeAndShowNets(); // also updates node list
  // Build mapping coord->netname
  const coordToRaw = sim.coordToRaw;
  const rawToIndex = sim.rawToIndex;
  const uniqRaw = sim.uniqRaw;
  // Create node map: raw -> N<x> string
  const nodeNames = {}; uniqRaw.forEach((raw,i)=> nodeNames[raw] = `N${raw}`);
  // Compose lines
  const lines = ['* Generated netlist'];
  // Components: R<id> nodeA nodeB value
  state.components.forEach(c=>{
    if(c.type === 'resistor'){
      const a = coordToRaw.get(`${Math.round(c.points[0].x)},${Math.round(c.points[0].y)}`);
      const b = coordToRaw.get(`${Math.round(c.points[1].x)},${Math.round(c.points[1].y)}`);
      lines.push(`R${c.id} ${nodeNames[a]} ${nodeNames[b]} ${Number(c.value)}`);
    } else if(c.type === 'vsource'){
      const a = coordToRaw.get(`${Math.round(c.points[0].x)},${Math.round(c.points[0].y)}`);
      const b = coordToRaw.get(`${Math.round(c.points[1].x)},${Math.round(c.points[1].y)}`);
      lines.push(`V${c.id} ${nodeNames[a]} ${nodeNames[b]} DC ${Number(c.value)}`);
    } else if(c.type === 'ground'){
      // ngspice expects ground named 0, we can map that node to 0 below
      const a = coordToRaw.get(`${Math.round(c.points[0].x)},${Math.round(c.points[0].y)}`);
      lines.push(`* ground node raw ${a}`);
    }
  });
  // Add control to print node voltages
  lines.push('.op');
  lines.push('.end');
  return lines.join('\n');
}

// Placeholder run function ‚Äî adapt to your WASM API
async function runNgSpice(netlist){
  if(!ngspiceReady) { log('NgSpice not loaded'); return null; }
  // Use ngspiceModule to run netlist and capture stdout/stderr results
  // Example pseudo:
  // const result = await ngspiceModule.run(netlist);
  // parse result to extract node voltages and currents and return object similar to computeAndShowNets()
  log('runNgSpice called ‚Äî adapt runNgSpice() to your ngspice API.');
  return null;
}

document.getElementById('runNgspiceBtn').addEventListener('click', async ()=>{
  const netlist = buildSpiceNetlist();
  log('Netlist built ‚Äî see console for netlist');
  console.log(netlist);
  // Attempt to run ngspice if loaded
  const res = await runNgSpice(netlist);
  if(res) {
    log('NgSpice run finished. (You provided a real ngspice-wasm implementation.)');
    // Parse and map results into UI (not implemented in placeholder)
  } else {
    log('NgSpice not run ‚Äî update loadNgSpice/runNgSpice to match your ngspice-wasm API.');
  }
});

/* =========================
   Utilities
   ========================= */
document.querySelectorAll('.palette .item').forEach(it=>{
  it.addEventListener('dragstart', e => e.dataTransfer.setData('text/plain', it.dataset.type));
});
svg.addEventListener('dragover', e => e.preventDefault());
svg.addEventListener('drop', e=>{
  e.preventDefault();
  const type = e.dataTransfer.getData('text/plain');
  const world = screenToWorld(e.clientX, e.clientY);
  const gridOn = document.getElementById('gridToggle').checked;
  const pt = gridOn ? {x: snapCoord(world.x), y: snapCoord(world.y)} : snapToTerminal(world);
  addComponent(type, pt.x, pt.y);
});

function findComponentById(id){ return state.components.find(c=>c.id==id); }
function findWireById(id){ return state.wires.find(w=>w.id==id); }
function applyInspectorValue(){ const sel = state.selection; if(!sel) return; if(sel.type==='component'){ const c = findComponentById(sel.id); if(c){ snapshot(); c.value = parseFloat(document.getElementById('selValue').value) || c.value; render(); }} else { const w = findWireById(sel.id); if(w){ snapshot(); w.label = document.getElementById('selValue').value; render(); } } }
document.getElementById('applyValue').addEventListener('click', applyInspectorValue);

</script>
</body>
</html>
